{% extends "base.html" %}
{% block content %}
<div class="row space">
  <div>
    <h2>Live Tracking</h2>
    <div class="muted">Order {{ order_id }} · Status: {{ status }}</div>
  </div>
  <div class="pillrow">
    <a class="btn btn-ghost" href="/orders">Back to Orders</a>
    {% if user.role == 'transporter' %}
      <button class="btn btn-light" id="navPickupBtn" type="button">Navigate to Pickup</button>
      <button class="btn btn-primary" id="navDropoffBtn" type="button">Navigate to Buyer</button>
    {% endif %}
  </div>
</div>

<div class="card">
  <div class="muted small">
    {% if user.role == 'transporter' %}
      Share your live location so the buyer can track delivery.
    {% else %}
      Buyer view: you'll see the transporter's last known location once they share it.
    {% endif %}
  </div>

  <div class="spacer"></div>

  {% if user.role == 'transporter' %}
    {% if not assigned %}
      <div class="muted small">Location sharing activates only after the buyer accepts your quote for this order.</div>
      <div class="spacer"></div>
    {% endif %}
    <div class="row">
      <button class="btn btn-primary" id="gpsStart" type="button" {% if not assigned %}disabled{% endif %}>Start sharing location</button>
      <button class="btn btn-light" id="gpsStop" type="button" disabled>Stop</button>
      <div class="muted small" id="gpsStatus" style="margin-left:10px;">Not sharing yet.</div>
    </div>
    <div class="spacer"></div>
  {% endif %}

  <div class="grid2">
    <div>
      <div id="map" style="height:420px; border-radius:14px; overflow:hidden;"></div>
      <div class="spacer"></div>
      <div class="muted small" id="trackInfo">Waiting for location…</div>
    </div>

    <div class="card">
      <h3 class="m0">Delivery timeline</h3>
      <div class="muted small">Clear, shared status for buyer, farmer and transporter.</div>
      <div class="spacer"></div>
      <div id="timeline" class="stack"></div>
      <div class="spacer"></div>
      <div class="muted small">Last transporter ping: <span id="lastUpdated">—</span></div>
    </div>
  </div>
</div>

<!-- Leaflet for maps (no install needed) -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<script>
(function(){
  const orderId = "{{ order_id }}";
  const role = "{{ user.role }}";
  const orderStatus = "{{ status }}";
  let lastBuyer = null;

  // map init (Abuja-ish default)
  const map = L.map('map').setView([9.06, 7.49], 12);
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19 }).addTo(map);

  let originMarker = null;
  let buyerMarker = null;
  let transporterMarker = null;
  let routeLine = null;      // pickup -> drop-off (approx)
  let legLine = null;        // transporter -> next target (approx)

  function setMarker(kind, loc){
    if(!loc) return;
    const lat = loc.lat, lng = loc.lng;
    if(kind === 'origin'){
      if(!originMarker) originMarker = L.marker([lat,lng]).addTo(map).bindPopup('Pickup');
      originMarker.setLatLng([lat,lng]);
    } else if(kind === 'buyer'){
      if(!buyerMarker) buyerMarker = L.marker([lat,lng]).addTo(map).bindPopup('Drop-off');
      buyerMarker.setLatLng([lat,lng]);
    } else {
      if(!transporterMarker) transporterMarker = L.marker([lat,lng]).addTo(map).bindPopup('Transporter');
      transporterMarker.setLatLng([lat,lng]);
    }
  }


  function parseTs(ts){
    if(!ts) return null;
    // stored as 'YYYY-MM-DD HH:MM:SS'
    const iso = ts.replace(' ', 'T');
    const d = new Date(iso);
    return isNaN(d.getTime()) ? null : d;
  }

  function ago(ts){
    const d = parseTs(ts);
    if(!d) return '—';
    const diffMs = Date.now() - d.getTime();
    const s = Math.max(0, Math.floor(diffMs/1000));
    if(s < 60) return `${s}s ago`;
    const m = Math.floor(s/60);
    if(m < 60) return `${m}m ago`;
    const h = Math.floor(m/60);
    if(h < 48) return `${h}h ago`;
    const days = Math.floor(h/24);
    return `${days}d ago`;
  }

  function firstEventTs(events, status){
    if(!events) return null;
    for(const e of events){
      if(e && e.status === status) return e.created_at;
    }
    return null;
  }

  function renderTimeline(j){
    const el = document.getElementById('timeline');
    if(!el) return;
    const steps = [
      {key:'PLACED', label:'Order placed', ts: j.order ? j.order.created_at : null},
      {key:'DROPOFF', label:'Buyer destination captured', ts: j.dropoff ? j.dropoff.created_at : null},
      {key:'PICKUP', label:'Farmer pickup shared', ts: j.origin ? j.origin.created_at : null},
      {key:'QUOTE_ACCEPTED', label:'Quote accepted', ts: firstEventTs(j.events, 'QUOTE_ACCEPTED')},
      {key:'EN_ROUTE_TO_PICKUP', label:'Transporter en route to pickup', ts: firstEventTs(j.events, 'EN_ROUTE_TO_PICKUP')},
      {key:'EN_ROUTE_TO_DROPOFF', label:'Picked up · en route to buyer', ts: firstEventTs(j.events, 'EN_ROUTE_TO_DROPOFF')},
      {key:'DELIVERED', label:'Delivered', ts: firstEventTs(j.events, 'DELIVERED')}
    ];

    // current status to highlight progress
    const status = (j.order && j.order.status) ? j.order.status : orderStatus;

    const rank = {
      'WAITING_FARMER_LOCATION': 1,
      'NEEDS_QUOTES': 2,
      'QUOTE_ACCEPTED': 3,
      'EN_ROUTE_TO_PICKUP': 4,
      'EN_ROUTE_TO_DROPOFF': 5,
      'DELIVERED': 6
    };
    const currentRank = rank[status] || 0;

    el.innerHTML = '';
    for(const s of steps){
      const done = !!s.ts;
      const item = document.createElement('div');
      item.className = 'row space';
      const left = document.createElement('div');
      left.innerHTML = `<div class="strong">${s.label}</div><div class="muted small">${s.ts ? s.ts : 'Pending'}</div>`;
      const right = document.createElement('div');
      const pill = document.createElement('span');
      pill.className = 'pill';
      if(done) pill.textContent = 'Done';
      else {
        // best-effort progress highlight
        const sRank = rank[s.key] || 0;
        pill.textContent = (sRank && currentRank >= sRank) ? 'In progress' : 'Pending';
      }
      right.appendChild(pill);
      item.appendChild(left);
      item.appendChild(right);
      el.appendChild(item);
      const hr = document.createElement('div');
      hr.className = 'line';
      hr.style.margin = '10px 0';
      el.appendChild(hr);
    }

    // last transporter ping
    const lastEl = document.getElementById('lastUpdated');
    if(lastEl){
      lastEl.textContent = j.transporter ? `${j.transporter.created_at} · ${ago(j.transporter.created_at)}` : '—';
    }
  }

  async function refresh(){
    try{
      const r = await fetch(`/api/order/${orderId}/track`, {headers:{'Accept':'application/json'}});
      const j = await r.json();
      if(!j.ok){
        document.getElementById('trackInfo').textContent = j.error || 'Not available';
        return;
      }
      lastBuyer = j.dropoff || null;
      window.__lastOrigin = j.origin || null;
      setMarker('origin', j.origin);
      setMarker('buyer', j.dropoff);
      setMarker('transporter', j.transporter);

      // Route lines (approximate straight lines)
      if(j.origin && j.dropoff){
        const pts = [[j.origin.lat, j.origin.lng],[j.dropoff.lat, j.dropoff.lng]];
        if(!routeLine){
          routeLine = L.polyline(pts).addTo(map);
        }else{
          routeLine.setLatLngs(pts);
        }
      }
      // Current leg: transporter -> next target
      if(j.transporter){
        let target = null;
        const st = (j.order && j.order.status) ? j.order.status : orderStatus;
        if(st === 'EN_ROUTE_TO_PICKUP' || st === 'QUOTE_ACCEPTED' || st === 'NEEDS_QUOTES' || st === 'WAITING_FARMER_LOCATION'){
          target = j.origin;
        }else{
          target = j.dropoff;
        }
        if(target){
          const pts2 = [[j.transporter.lat, j.transporter.lng],[target.lat, target.lng]];
          if(!legLine){
            legLine = L.polyline(pts2).addTo(map);
          }else{
            legLine.setLatLngs(pts2);
          }
        }
      }

      // Timeline + last updated badge
      renderTimeline(j);


      // fit bounds when we have at least transporter
      const pts = [];
      if(j.origin) pts.push([j.origin.lat, j.origin.lng]);
      if(j.dropoff) pts.push([j.dropoff.lat, j.dropoff.lng]);
      if(j.transporter) pts.push([j.transporter.lat, j.transporter.lng]);
      if(pts.length){
        map.fitBounds(pts, {padding:[30,30]});
      }
      const t = j.transporter ? `Transporter: ${j.transporter.lat.toFixed(5)}, ${j.transporter.lng.toFixed(5)} (${j.transporter.created_at})` : 'Transporter has not shared location yet.';
      document.getElementById('trackInfo').textContent = t;
    }catch(e){
      document.getElementById('trackInfo').textContent = 'Refresh failed (network).';
    }
  }

  refresh();
  setInterval(refresh, 10000); // 10s poll

  // Navigation gating: drop-off navigation becomes primary after pickup is confirmed.
  if(role === 'transporter'){
    const dropBtn = document.getElementById('navDropoffBtn');
    if(dropBtn){
      if(orderStatus === 'EN_ROUTE_TO_PICKUP' || orderStatus === 'QUOTE_ACCEPTED'){
        dropBtn.classList.add('btn-light');
        dropBtn.classList.remove('btn-primary');
      }
    }
  }

  // One-tap Google Maps navigation (pickup first, then drop-off).
  if(role === 'transporter'){
    const pickupBtn = document.getElementById('navPickupBtn');
    const dropBtn = document.getElementById('navDropoffBtn');

    function openDir(dest){
      const url = `https://www.google.com/maps/dir/?api=1&destination=${dest.lat},${dest.lng}&travelmode=driving`;
      window.open(url, '_blank');
    }

    if(pickupBtn){
      pickupBtn.addEventListener('click', function(){
        // pickup = origin
        if(!window.__lastOrigin){
          alert('Pickup GPS not available yet.');
          return;
        }
        openDir(window.__lastOrigin);
      });
    }

    if(dropBtn){
      dropBtn.addEventListener('click', function(){
        if(!lastBuyer){
          alert('Buyer destination GPS not available yet.');
          return;
        }
        openDir(lastBuyer);
      });
    }
  }

  // If transporter, hook up GPS buttons using browser geolocation.
  if(role === 'transporter'){
    let watchId = null;

    const startBtn = document.getElementById('gpsStart');
    const stopBtn = document.getElementById('gpsStop');
    const statusEl = document.getElementById('gpsStatus');

    function setState(running){
      startBtn.disabled = running;
      stopBtn.disabled = !running;
    }

    async function postLoc(p){
      const payload = {
        lat: p.coords.latitude,
        lng: p.coords.longitude,
        accuracy: p.coords.accuracy
      };
      try{
        await fetch(`/api/order/${orderId}/location`, {
          method:'POST',
          headers:{'Content-Type':'application/json'},
          body: JSON.stringify(payload)
        });
        statusEl.textContent = `Sharing… accuracy ${Math.round(payload.accuracy||0)}m`;
      }catch(e){
        statusEl.textContent = 'Sharing… but post failed (network).';
      }
    }

    startBtn.addEventListener('click', function(){
      if(!navigator.geolocation){
        statusEl.textContent = 'Geolocation not supported on this browser.';
        return;
      }
      setState(true);
      statusEl.textContent = 'Requesting permission…';
      watchId = navigator.geolocation.watchPosition(
        postLoc,
        function(err){
          statusEl.textContent = 'Location error: ' + err.message;
          setState(false);
        },
        {enableHighAccuracy:true, maximumAge:10000, timeout:15000}
      );
    });

    stopBtn.addEventListener('click', function(){
      if(watchId !== null && navigator.geolocation){
        navigator.geolocation.clearWatch(watchId);
      }
      watchId = null;
      setState(false);
      statusEl.textContent = 'Stopped.';
    });
  }
})();
</script>
{% endblock %}
